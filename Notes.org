* Software Engineering
** 15-1-20
*** UML Diagrams for projects
**** Requirements
     + Conceptual class 
     + Use case
     + Activity
**** Design
     + Detailed class diagram
     + Design pattern
     + Sequence diagram
*** Software vs Hardware
    + Touch
    + Primary responsibility
    + Fast build iterations
    + Software is developed or engineered, not manufactured
    + Software doesn't wear out
    + Software is usually custom built
    + /See graph of degradation curve/
    + Technical Debt: Implied cost of additional rework caused by choosing an easy solution now,
      instead of a better solution that would take longer.
*** Software Applications
    + System Software
    + Application Software
    + Engineering/Scientific Software
    + Embedded Software
    + Product-line Software
    + Web/Mobile Applications
    + AI Software (Robotics, neural nets, game playing)
*** Legacy Software
    Software must be:
    + adapted to fit new requirements
    + enhanced to implement new business requirements
    + extened to make it interoperable with more modern systems or databases
    + re-architected to make it viable within a network environment
*** Software Engineering?
    + Design Practice
    + Problem Solving
    + Top Down View
**** Quality Software
     + Efficient
     + Cost Effectiv
**** Some Realities
     + Understand the problem /first/
     + Design is a pivotal activity
     + Software should be of high quality
     + Software should be maintainable
** 17-1-20
*** Intro
    + Remember Piazza discussion forum
*** DONE Go over group selection and initial requirements for group project
    + Full requirements
    + Full design
    + Partial implementation
    + Testing of partial implementation
    + Will cover method for utilizing initial requirements in class
      next week.
*** Lines of code/Time
    + How long does it take to write one line of code?
      - Trick question: not an accurate metric for measuring efficiency.
*** Process Framework
**** Communication
     + Sponsor
***** Stakeholder
****** Internal
       + Boss
       + Team
	 - Tester
	 - Dev
       + Management
       + Sponsor
****** External
       + Customer
       + Govt Policy Provider
       + Shareholder
       + Grant Organizations
**** Planning
     + Cost
     + Resources
     + Time
**** Modeling
     + Analysis of Requirements
     + Design
**** Umbrella Activities
     + Software project tracking and control
       - Project manager determines whether project is on track
     + Risk management
     + Quality assurance
     + Technical reviews
     + Measurement
     + Software configuration management
     + Work product preparation and production
***** What is Risk Management?
      + Risk is the product of the likelihood someone is exposed to
        something bad, and the consequence of exposure.
      + Risk matrix uses info about likelihood and consequence to
        determine actual risk.
      + Many different types of risk matricies exist.
      + They can have different definitions of low and high likelihood
        and consequence. Regardless, they all follow the same principles.
***** Understand the problem -> Plan a solution
**** Hooker's Principles
     + The Reason it All Exists
     + Keep It Simple Stupid
     + Maintain the vison
** 22-1-20
*** Intro
**** Due dates have changed
**** You should be reading UML 2.0 book
     + Use case diagrams
     + Class diagrams
     + Activity diagrams
*** Group Project
**** Group 9
     + Cole Brooks
     + Justin Guerrero
     + Cory Lagor
     + Nathan Rubino
     + William Walkuski
**** Separate group by requirements
     + Only one person needs to submit the entire assignment, each person
       much submit their individual piece.
     + Each person submits:
       - a set of use cases, and use case descriptions that break down one
         or more of these uses. Submit in a pdf.
       - Class diagrams
       - Activity diagrams
**** DONE Come up with interview questions based on requirements. Interview on Monday.
*** Essence of Practice
**** Polya Suggests
***** Understand the problem
      + Who has a stake in the problem?
      + What are the unknowns?
      + Can the problem be compartmentalized?
      + Can it be represented graphically?
***** Plan a solution
      + Design
      + Have you seen similar problems before?
      + Has a similar problem been solved?
      + Can subproblems be defined?
      + Can you represent a solution in a manner that can actually be
        implemented? 
***** Implementation
      + Does the solution conform to the plan?
      + In each component of the solution provably correct?
***** Examine the Result
      + Testing
      + Is it possible to test each component of the solution?
      + Does the solution produce results that conform to the data,
        functions, and features that are required?
*** Hooker's General Principles
    + The Reason It All Exists
    + Keep It Simple Stupid
    + Maintain The Vision
    + What You Produce, Others Will Consume
    + Be Open To The Future
    + Plan Ahead For Reuse
    + Think!
*** Software Myths
    + Affect managers, customers, and practitioners.
    + Often have elements of truth, which can make the easiliy
      believable. 
    + Lead to bad decisions.
    + *Therefore*, insist on reality as you navigate through software
      engineering. 
*** Understanding Requirements
    + Tell us what the system has to do, features to be delivered.
**** Requirements Engineering
     + Continue on Friday.
** 24-1-20
*** TODO Requirements Assignment
    DEADLINE: <2020-02-19 Wed 12:00>
*** DONE Check class calendar
*** TODO Test on 14-2-20
*** Requirements Engineering
**** Definition
     + Set of activities concerned with identifying and communicating
       the purpose of a software intensive system, and the context in
       which it will be used.
     + Acts as the bridge between the real world needs of users,
       customers, and others affected by a software system and the
       capabilities and opprtunities afforded by software intensive
       technologies.
**** Error Correction
     + Becomes exponentially more expensive as the life of the project
       continues. i.e., *figure out requirements early*.
**** Inception
     + Ask a set of questions that establish:
       - Basic understanding
       - Who wants the solution
       - Nature of desired solution
**** Elicitation
     + Elicit requirements from all stakeholders
**** Elaboration
     + Create an analysis model that identifies data, functions, etc.
**** Negotiation
     + Agree on a deliverable system that is realistic for developers
       and consumers.
**** Specification
     + Can be any of the following:
       - Written document
       - Set of models
       - Formal mathematical model
       - Use-cases
       - Prototype
**** Validation
     + A review mechanism that looks for:
       - Errors
       - Required clarification
       - Missing info
       - Inconsistencies
       - Conflicting or unrealistic requirements
**** The goal:
     + Identify problem
     + Propose solution
     + Negotiate different approaches
**** Requirements
***** Functional
      + Required behaviour of system between inputs and outputs
***** Non-functional
      + Required behaviour of the users of the system rather than the
        system itself. 
***** Characteristics of good requirements
      + Unambiguous
      + Testable
      + Clear
      + Correct
      + Understandable
      + Feasible
      + Independent
      + Atomic
      + Necessary
      + Implementation-free (abstract)
***** TODO Only functional requirements are required for assignment
**** FQT
     + Formal Quality Testing, testing team, making sure software is
       bulletproof. Or as bulletproof as possible. Bugtesting. 
** 27-1-20
*** Group Project Meeting
**** Interview Questions
***** Users
      + Who is using it
      + Do different users need different functionality?
***** Scope
      + What systems do you already have?
      + What do you like and dislike about them?
      + Intended to integrate with or replace existing systems?
***** How long is the system intended to be in use?
***** Transfer credit database
***** Portability
      + Will other campuses be using it also, or just MSU Bozeman?
***** Registration optimization
      + What is your ideal layout?
***** Should we integrate/optimize the functionality of CatCourse/DegreeWorks?
**** Question Priority
***** Necessary
      + How long is this to be in use?
      + Transfer credit database
      + Portability
      + Integrate with or replace current systems?
	- Dislikes searching for CRNs
	- Dislikes separated nature of current system.
	- Likes seeing mulitple sections.
	- System should be mostly standalone, should replace the
          disjointed nature of our current system, but also shouldn't
          prohibit the transfer of data between our system and current
          systems. 
      + Are any of your requirements unnecessary?
      + How much should administration have to change about their
        current methods?
	- Administration (Registrar) will import their data from their
          own program, so they will not have to worry about learning
          our new software. 
***** Nice to Have
      + How many semesters ahead should be shown? Timeline?
      + Pros and cons of current systems
      + Security vs Convenience
      + Level of integration between registration, graduation track
        and scheduling.
***** Last Priority
      + Should different paths between majors be explicitly separated?
      + Ideal registration layout
	- Ask about after we have designed a few examples to get her
          opinion on preferred style/function. 
**** NOTE: 
     + The registrar can set up the course curriculum from outside our contracted system.
*** Class
**** Requirement Examples
***** Bad Examples
      + Email notification must include the relevant info.
	- What is "relevant info"?
	- Good: The email notification must include dollar amount,
          date, and ID number. 
**** The Waterfall Model
     + Has problems because it is completely linear, so going back
       often translates to starting over.
     + Has the perks of being more bulletproof, is userful for
       software design with low tolerance for mistakes/compromise. 
**** Potential Project Requirements/Desires
     + Professor can get course emails.
     + Students can use the system to determine all core classes for
       the semester.
     + Students can use the system for generating a campus map of
       their classes for the semester.
     + Wants information to be derived from current semester's roll.
     + Wants easier way to see amount of seats in each section.
     + Wants to see all CS classes not just CSCI.
     + Needs a mobile version!
     + Easily available book info
     + Should be intended just for MSU Bozeman, but should plan for
       ease of extensibility to other MSU campuses, or even other
       universities entirely.
     + Would be nice to have links to professor/faculty webpages in
       order to have easy access to contact info and office hours.
     + All users should be able to log in with NetID and password in
       order to have access to their relevant information, e.g. class
       roster, graduation track, etc.
* Systems Administration
** 16-1-20
   + End users often are uncomfortable talking to a SysAdmin and often worry
     about being perceived as stupid or negligent.
   + End users often have misinformation or a bad understanding on how
     something works.
   + Up to the SysAdmin to ask questions before providing answers in order to
     better understand the problem/bigger picture.
   + End users can often have good ideas, make sure to acknowledge them
   + Don't be afraid to say you don't know and that you need to do some research
   + Make sure to follow through to completion in a timely fashion.
   + Follow up to ensure the solution has continued to work.
   + Recognize when you need to created documentation for yourself/others. Use
     FAQs and provide users with as much documentation as they are
     comfortable with.
   + Try to track problems and recognize trends with users, software, and
     hardware.
   + End users often don't formulate questions well
** 21-1-20
*** Installing CentOS
    + www.centos.org
    + Install from installation media ISO.
    + Rufus or dd to make USB bootable
    + GPT partitions needed for drives with more than 2Tb
    + Can configure partitions in many ways, I prefer boot, swap,
      root, and home.
      + 
** 23-1-20
*** UNIX Command Line Usage
**** Bash Hotkeys
     + Bash just uses Emacs hotkeys. I said as I typed this into
       Emacs.
**** Job Control
     + Bash allows for multitasking by offering job control.
     + C-z suspends a process in Bash.
     + "jobs" list jobs.
     + Following a command with "&" launches it in the background and
       returns to the shell entry.
     + "fg" and "bg" allows to switch between foreground and
       background processes. 
**** TMUX
     + Terminal multiplexer to use multiple shells in one instance of
       a terminal emulator. 
**** Your ENVironment
     + "env" prints a list of environment variables.
     + To update or create an environment variable use the export
       command.
       - Keep in mind that this is only for the current session.
     + Default editor if $EDITOR isn't set is vi.
**** MAN pages
     + Know the different sections of the man pages, this will be on
       the exam.
** 28-1-20
**** DONE Homework 1, User Accounts
**** Passwords
     + Avoid using a text editor to edit text files, can result in
       syntax errors or multiple users editing a file.
* Programming Languages
** 17-1-20
*** DONE Read chapters 1 and 2
** 22-1-20
*** Ternary operator
    + Has three arguments, e.g "?" in Java.
    + Too many ways to do the same thing can result in confusion
      between programmers.
*** Feature creep
    + Ada tried to combine FORTRAN and COBOL.
      - After 10 years it was so bloated that it was impossible to use cohesively.
*** Readability, writability, reliability, and cost.
    + See table 1.1 in the book
**** Readability
     + Overall simplicity
       - Minimal feature multiplicity
	 * count = count + 1
	 * count += 1
	 * count++
	 * ++count
       - Minimal operator overloading.
     + Orthogonality
       - Relatively small set of primitive constructs can be combined
         in a relatively small number of ways.
       - Every possible combination is legal.
       - Pass by reference and pass by value (arrays are different
         than primitives, and objects are different.)
       - Different languages can read expressions left to right or
         vice versa. Keep in mind. 
     + Data types
       - Adequate predefined data types.
     + Syntax
       - Form and meaning, self-descriptive constructs, meaningful keywords.
       - 
**** Writability
** 24-1-20
*** DONE Fortran Assignment
    DEADLINE: <2020-02-07 Fri 17:00>
** 29-1-20
*** Plankalkul
    + First programming language
    + Designed in 1945, not published until 1972.
    + Never implemented
    + Advanced data structures :: Floating points, arrays, records
**** Syntanx
       | A + 1 = > A
     V | 4         5
     S | 
*** Pseudocodes
    + Minimal programming languages used to get around the painful
      process of programming in machine code.
**** Short Code
     + Univac
**** Speedcoding 
     + IBM 701
     + Pseudo ops for math functions
     + Conditional and unconditional branching
     + Auto-increment registers for array accesses
     + Slow!
     + Only 700 words left for user program
*** IBM 704 and Fortran
**** Fortran I
     + Regarded as one of the first high level programming languages
     + Compiler released in April 1957 after 18 worker-years of effort
     + No need for dynamic storage
     + Need good array handling and counting loops
     + DO loop
     + Formatted I/O
     + Programs larger than 400 lines rarely compiled correctly, mainly
       due to poor reliability of IBM 704
     + Code was very fast
     + Quickly became very widely used
*** LISP
    + All in Lambda Calculus
    + Made for AI study
    + Pioneered functional programming :: No need for variables or assignment
    + Still used for AI
    + Common Lisp and Scheme are contemporary dialects of Lisp
    + ML, Haskell, and F# are also functional programming languages,
      but use very different syntax. 
*** COBOL
    + First language for business and not engineering
    + Designed to be read like a natural language
    + First language required by DoD, would likely have failed without DoD
*** Basic
    + Easy to learn ans use for non-science students
    + Must be "pleasant and friendly"
    + Fast turnaround for homework
    + Free and private access
    + *User time is more important that computer time*
    + Current popular dialect :: Visual Basic
    + First widely used language with time sharing
*** Pascal
    + First designed for teaching structured programming
    + Small, simple, nothing new
    + Largest impact was on teaching programming :: From mid 70's to
      late 90's was the most widely used programming
      language for teaching programming
* German
** 20-1-20
*** DONE Look in to buying textbook for German class
** 22-1-20
*** DONE Homework 4.1
    DEADLINE: <2020-01-22 Wed 23:59>
*** DONE Quiz on Friday
    SCHEDULED: <2020-01-24 Fri 09:00>
*** DONE Homework 4.2
    DEADLINE: <2020-01-27 Mon 23:59>
** 29-1-20
*** TODO Homework
    DEADLINE: <2020-02-03 Mon 23:59>
